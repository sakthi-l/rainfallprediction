# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wIf54lJFQp5P1VuTVstB9OWnu9Toqk4-
"""

# ============================================================
# üå¶Ô∏è Combined Rainfall Forecast + Flood/Drought Prediction App
# ============================================================

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.linear_model import LassoCV
from sklearn.preprocessing import RobustScaler
from sklearn.model_selection import TimeSeriesSplit
from xgboost import XGBClassifier
from imblearn.over_sampling import SMOTE
from sklearn.preprocessing import LabelEncoder, OneHotEncoder

# ------------------------------------------------------------
# LOAD DATASETS
# ------------------------------------------------------------
@st.cache_data
def load_data():
    rain = pd.read_csv("Rainfall_Data_LL.csv")
    rain.columns = rain.columns.str.strip().str.upper()

    flood = pd.read_csv("rainfallpred.csv")
    flood.columns = flood.columns.str.strip().str.upper()
    return rain, flood

rain_df, flood_df = load_data()

# ------------------------------------------------------------
# FLOOD / DROUGHT MODEL TRAINING
# ------------------------------------------------------------
@st.cache_resource
def train_flood_model(flood_df):
    months = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC']
    flood_df['TOTAL'] = flood_df[months].sum(axis=1)
    flood_df['REGION_MEAN'] = flood_df.groupby('SUBDIVISION')['TOTAL'].transform('mean')
    flood_df['REGION_STD'] = flood_df.groupby('SUBDIVISION')['TOTAL'].transform('std')
    flood_df['SPI_REGION'] = (flood_df['TOTAL'] - flood_df['REGION_MEAN']) / flood_df['REGION_STD']
    flood_df['DROUGHT_PCTL'] = flood_df.groupby('SUBDIVISION')['TOTAL'].transform(lambda x: x.quantile(0.05))
    flood_df['FLOOD_PCTL'] = flood_df.groupby('SUBDIVISION')['TOTAL'].transform(lambda x: x.quantile(0.95))

    def classify(row):
        if row['SPI_REGION'] <= -1 or row['TOTAL'] < row['DROUGHT_PCTL']:
            return "Drought"
        elif row['SPI_REGION'] >= 1.5 or row['TOTAL'] > row['FLOOD_PCTL']:
            return "Flood"
        else:
            return "Normal"

    flood_df['LABEL'] = flood_df.apply(classify, axis=1)

    enc = OneHotEncoder(handle_unknown='ignore', sparse_output=False)
    region_encoded = pd.DataFrame(enc.fit_transform(flood_df[['SUBDIVISION']]),
                                  columns=enc.get_feature_names_out(['SUBDIVISION']))
    flood_df = pd.concat([flood_df, region_encoded], axis=1)

    feature_cols = months + list(region_encoded.columns)
    X = flood_df[feature_cols]
    y = flood_df['LABEL']

    sm = SMOTE(random_state=42)
    X_res, y_res = sm.fit_resample(X, y)

    le = LabelEncoder()
    y_enc = le.fit_transform(y_res)

    clf = XGBClassifier(
        n_estimators=300, max_depth=5, learning_rate=0.05,
        subsample=0.8, colsample_bytree=0.8,
        objective='multi:softprob', num_class=3, random_state=42
    )
    clf.fit(X_res, y_enc)

    return clf, le, enc, feature_cols, months

clf, le, enc, feature_cols, months = train_flood_model(flood_df)

# ------------------------------------------------------------
# FLOOD/DROUGHT PREDICTION FUNCTION
# ------------------------------------------------------------
def predict_flood(region, monthly_vals):
    region_encoded = pd.DataFrame(np.zeros((1, len(enc.get_feature_names_out(['SUBDIVISION'])))),
                                  columns=enc.get_feature_names_out(['SUBDIVISION']))
    if f"SUBDIVISION_{region}" in region_encoded.columns:
        region_encoded[f"SUBDIVISION_{region}"] = 1

    manual_df = pd.DataFrame([monthly_vals], columns=months)
    features = pd.concat([manual_df, region_encoded], axis=1)[feature_cols]
    pred = np.argmax(clf.predict_proba(features), axis=1)
    return le.inverse_transform(pred)[0]

# ------------------------------------------------------------
# RAINFALL FORECAST (LASSO MODEL)
# ------------------------------------------------------------
def forecast_rainfall(region_chosen, year_input):
    df = rain_df[rain_df["SUBDIVISION"].str.contains(region_chosen, case=False, na=False)]
    if df.empty:
        return None, None, "Region not found!"

    data = df.groupby("YEAR")["ANNUAL"].mean().reset_index().dropna().sort_values("YEAR")
    for i in range(1, 6):
        data[f"LAG{i}"] = data["ANNUAL"].shift(i)
    data = data.dropna().reset_index(drop=True)

    feature_cols = [c for c in data.columns if c not in ['YEAR', 'ANNUAL']]
    X_train = data[feature_cols].values
    y_train = data["ANNUAL"].values

    scaler = RobustScaler()
    X_scaled = scaler.fit_transform(X_train)
    tscv = TimeSeriesSplit(n_splits=min(5, len(X_scaled)//5))
    lasso = LassoCV(cv=tscv, random_state=42, max_iter=10000).fit(X_scaled, y_train)

    last_row = data.iloc[-1]
    future = pd.DataFrame([last_row.values], columns=data.columns)
    future["YEAR"] = year_input
    for i in range(1, 6):
        future[f"LAG{i}"] = last_row["ANNUAL"] if i == 1 else last_row[f"LAG{i-1}"]

    X_future = scaler.transform(future[feature_cols].values)
    prediction = float(lasso.predict(X_future)[0])
    return prediction, data, None

# ------------------------------------------------------------
# STREAMLIT UI
# ------------------------------------------------------------
st.set_page_config(page_title="Rainfall & Flood/Drought Predictor", layout="centered")
st.title("üåßÔ∏è Rainfall Forecasting and Flood/Drought Prediction")

menu = st.sidebar.radio("Select Option:", ["Rainfall Forecast", "Flood/Drought Classification"])

# ---------------- Rainfall Forecast -------------------------
if menu == "Rainfall Forecast":
    st.header("üìà Rainfall Forecast using LASSO Regression")
    region = st.text_input("Enter Region (Subdivision):")
    year = st.number_input("Enter Year to Forecast:", min_value=1900, max_value=2100, value=2025)

    if st.button("Forecast Rainfall"):
        pred, data, err = forecast_rainfall(region, year)
        if err:
            st.error(err)
        else:
            st.success(f"Predicted Annual Rainfall for {region.title()} in {year}: **{pred:.2f} mm**")
            st.line_chart(data.set_index("YEAR")["ANNUAL"])

# ---------------- Flood/Drought Classification --------------
if menu == "Flood/Drought Classification":
    st.header("üåä Flood/Drought Prediction using XGBoost")

    regions = sorted(flood_df['SUBDIVISION'].unique())
    region = st.selectbox("Select Region:", regions)
    st.markdown("Enter Monthly Rainfall (mm):")
    monthly_vals = []
    cols = st.columns(4)
    for i, m in enumerate(months):
        with cols[i % 4]:
            monthly_vals.append(st.number_input(m, min_value=0.0, max_value=2000.0, value=100.0))

    if st.button("Predict Flood/Drought"):
        label = predict_flood(region, monthly_vals)
        if label == "Flood":
            st.error(f"üåä Prediction: {label}")
        elif label == "Drought":
            st.warning(f"üåµ Prediction: {label}")
        else:
            st.success(f"üå¶Ô∏è Prediction: {label}")